<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="UTF-8">









  
  
  
    
  


  


  


  










  <title>在 JavaScript 中面向对象编程 - 欧雷共享的内容</title>


  <meta property="og:title" content="在 JavaScript 中面向对象编程">




  
    
  


  <meta name="keywords" content="欧雷,欧雷流">


<!-- 页面渲染兼容性 -->
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!-- 订阅 -->

<meta name="theme-color" content="#0871ab">
<link rel="shortcut icon" href="/images/ksio/favicon.ico">


    
<link rel="stylesheet" href="/stylesheets/global.css">

    
<link rel="stylesheet" href="/stylesheets/ksio/vendors/share.css">

<link rel="stylesheet" href="/stylesheets/local/syntax-highlighting.css">

    
  
    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = '//hm.baidu.com/hm.js?e6d6bb6702dbd74ffbc950a57ad9b6be';
  var s = document.getElementsByTagName('script')[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
    
  


    
<script src="/javascripts/ksio/vendors/jquery-1.11.3.min.js"></script>

    
<script src="/javascripts/ksio/vendors/bootstrap.min.js"></script>

  </head>
  
  
  <body class="Page" itemscope itemtype="http://schema.org/WebPage">
    

  <header class="Page-header">
  <div class="navbar navbar-static-top">
    <div class="container">
      <div class="navbar-header">
        
          <button class="navbar-toggle collapsed" type="button" data-target=".Page-navs" data-toggle="collapse">
            <span class="sr-only">Toggle navs</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        
        
          <div class="navbar-brand">


  <a href="https://ourai.ws/?utm_source=https://s.ourai.ws&utm_medium=brand" target="_blank" rel="external nofollow">Ourai.WS</a><a href="/">共享</a>

</div>
        
      </div>
      <!-- Nav menus -->
      <nav class="Page-navs navbar-collapse collapse">
        <ul class="nav navbar-nav navbar-right">
          
  
    <li class="dropdown">
      <a class="dropdown-toggle" href="javascript:void(0);" data-toggle="dropdown">关于 <span class="caret"></span></a>
      <ul class="dropdown-menu">
  
    <li><a href="https://linxoid.com/ourai/?utm_source=https://s.ourai.ws&amp;utm_medium=common-header" target="_blank" rel="external nofollow">站长</a>
</li>
  

  
    <li><a href="https://ourai.ws/sponsor/?utm_source=https://s.ourai.ws&amp;utm_medium=common-header" target="_blank" rel="external nofollow">赞助</a>
</li>
  

  
    <li><a href="https://yaol.in/cooperation/?utm_source=https://s.ourai.ws&amp;utm_medium=common-header" target="_blank" rel="external nofollow">合作</a>
</li>
  

</ul>
    </li>
  


        </ul>
      </nav>
    </div>
  </div>
</header>

<main class="Page-content">
  

  <!-- 内容主体 -->
  <div class="container">
    <article class="Page-main Article">
      <header class="Article-header">
        
  
    <h1 class="Article-title">在 JavaScript 中面向对象编程</h1>
  
  


      </header>
      <div class="Article-content col-md-9"><p>「面向对象编程」即「OOP」（下文都用此称呼）是使用 JS 时最直觉最基本的编程范式。</p>
<h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><p>由于很多人在进行 OOP 时更熟悉像 Java 这种<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Class-based_programming">基于类的编程方式</a>，因而在用 JS 编程时会去追逐类的影子，进而产生了一种模拟类的继承方式——类式继承（classical inheritance）。</p>
<p>这部分内容的语境置于基于类的编程方式中，所以「对象」是类，或者说构造函数，实例化的产物，而非 JS 中对象本身的意义。</p>
<h3 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h3><p>在尚未有语法层面的支持之时，人们利用构造函数与原型链去模拟类。</p>
<p>假设父构造函数及其原型定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Adam&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面为各种不同的子构造函数定义及继承方式——</p>
<h4 id="默认模式"><a href="#默认模式" class="headerlink" title="默认模式"></a>默认模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br></code></pre></td></tr></table></figure>

<p>缺点：子构造函数的参数无法传入父构造函数中。</p>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>Rent-a-Constructor</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>缺点：父构造函数原型上的方法没被继承。</p>
<h4 id="借用和设置原型"><a href="#借用和设置原型" class="headerlink" title="借用和设置原型"></a>借用和设置原型</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br></code></pre></td></tr></table></figure>

<h4 id="共享原型"><a href="#共享原型" class="headerlink" title="共享原型"></a>共享原型</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure>

<p>优点：缩短子对象访问方法时在原型链上的查找路径。</p>
<p>缺点：修改子构造函数的原型会影响到父构造函数的原型。</p>
<h4 id="临时构造函数"><a href="#临时构造函数" class="headerlink" title="临时构造函数"></a>临时构造函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 利用 IIFE 创建闭包以避免代理构造函数被反复创建</span><br><span class="hljs-keyword">var</span> inherit = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">C, P</span>) &#123;<br>    <span class="hljs-comment">// 使用代理以避免子孙对象的修改影响到祖先</span><br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = P.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br><br>    <span class="hljs-comment">// 模拟「超类」</span><br>    C.<span class="hljs-property">super</span> = P.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><br>    <span class="hljs-comment">// 纠正指向以在类型检查时得到「正确」的结果</span><br>    C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = C;<br>  &#125;<br>&#125;)();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br><br><span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Child</span>, <span class="hljs-title class_">Parent</span>);<br></code></pre></td></tr></table></figure>

<h3 id="现代做法"><a href="#现代做法" class="headerlink" title="现代做法"></a>现代做法</h3><p>有了语法层面的支持，若用基于类的方式编程，体验变得更好了！</p>
<h4 id="ES-Classes"><a href="#ES-Classes" class="headerlink" title="ES Classes"></a>ES Classes</h4><p>从 ES6 开始在语法层面支持了<a target="_blank" rel="noopener" href="https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions">以类的方式进行定义</a>，即便底层依然是基于原型实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  #name;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Adam&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="TypeScript-Classes"><a href="#TypeScript-Classes" class="headerlink" title="TypeScript Classes"></a>TypeScript Classes</h4><p>在 TS 中<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/classes.html">天然支持类</a>，并且更为「标准」。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Adam&#x27;</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">say</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>原型继承（prototypal inheritance）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Adam&#x27;</span>,<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br></code></pre></td></tr></table></figure>

<h2 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h2><p>对象复制（object copying）技术是通过对已有对象进行「复制」以达到复用的目的，常见方式有浅复制（shallow copy）与深复制（deep copy）两种。</p>
<p>在复制属性时，只复制源对象的自身属性，也就是说，位于原型链上的属性不去复制。</p>
<h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>浅复制只是简单地将源对象的第一层属性的值赋给目标对象的相应属性上，如果值是对象（数组、函数都算），则在目标对象与源对象中都指向同一个地址。</p>
<p>这就意味着，修改其中一个对象的作为属性值的对象的某个属性，则会影响另一个对象。</p>
<h4 id="内置支持"><a href="#内置支持" class="headerlink" title="内置支持"></a>内置支持</h4><p>JS 中在语法或内置 API 层面也有一些进行浅复制的方式：</p>
<ul>
<li>展开语法 <code>...</code>；</li>
<li><code>Array.prototype.slice()</code>；</li>
<li><code>Array.prototype.concat()</code>；</li>
<li><code>Array.prototype.map()</code>；</li>
<li><code>Array.prototype.filter()</code>；</li>
<li><code>Array.from()</code>；</li>
<li><code>Object.assign()</code>；</li>
<li><code>Object.create()</code>。</li>
</ul>
<h4 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">source, target</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> k;<br><br>  target = target || (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(source) === <span class="hljs-string">&#x27;[object Array]&#x27;</span> ? [] : &#123;&#125;);<br><br>  <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>      target[k] = source[k];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>深复制通过完全地深度复制解决了浅复制的对象类属性值的修改问题，目标对象中每一层级都是全新的，不与源对象中的属性值共享地址；但也有像函数等例外。</p>
<h4 id="内置支持-1"><a href="#内置支持-1" class="headerlink" title="内置支持"></a>内置支持</h4><p>若被复制的是个纯对象或由纯对象构成的数组，且不存在循环引用，那就可被序列化，即可使用内置 API：</p>
<ul>
<li><code>JSON.parse(JSON.stringify())</code>；</li>
<li><code>structuredClone()</code>。</li>
</ul>
<h4 id="手动实现-1"><a href="#手动实现-1" class="headerlink" title="手动实现"></a>手动实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">source, target</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> toStr = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br>  <span class="hljs-keyword">var</span> arrType = <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>  <span class="hljs-keyword">var</span> k, v;<br><br>  target = target || (toString.<span class="hljs-title function_">call</span>(source) === arrType ? [] : &#123;&#125;);<br><br>  <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (!source.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    v = source[k];<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> v === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>      target[k] = <span class="hljs-title function_">extend</span>(v, toStr.<span class="hljs-title function_">call</span>(v) === arrType ? [] : &#123;&#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      target[k] = v;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该实现中未处理循环引用和特殊类型对象的问题，实际使用时可进一步优化。</p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>在 JS 中，混入（mixin）是一个可被复用的对象，它提供用于默认数据的变量及包含处理数据逻辑的函数。</p>
<p>可利用一个或多个此类对象组合创建出新的对象，或在已有对象上进行功能扩展——达到不去继承就能复用的效果，且可起到类似多重继承的作用。</p>
<p>在实际使用时会用到上面提到的对象复制技术。</p>
<p>将手动实现的 <code>extend()</code> 函数做些调整，让它支持动态参数，并能被参数控制是浅复制还是深复制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> args = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">var</span> length = args.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">var</span> target = args[<span class="hljs-number">0</span>] || &#123;&#125;;<br>  <span class="hljs-keyword">var</span> deep = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> isArr = <span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(t) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>; &#125;;<br>  <span class="hljs-keyword">var</span> src, obj, k, v;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;boolean&#x27;</span>) &#123;<br>    deep = target;<br>    target = args[<span class="hljs-number">1</span>] || &#123;&#125;;<br>    i = <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (i &lt; length) &#123;<br>    src = args[i];<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> src === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>      <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> src) &#123;<br>        <span class="hljs-keyword">if</span> (!src.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        v = src[k];<br><br>        <span class="hljs-keyword">if</span> (deep &amp;&amp; <span class="hljs-keyword">typeof</span> v === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArr</span>(v)) &#123;<br>            obj = <span class="hljs-title function_">isArr</span>(target[k]) ? target[k] : [];<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj = target[k] || &#123;&#125;;<br>          &#125;<br><br>          target[k] = <span class="hljs-title function_">extend</span>(deep, obj, v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          target[k] = v;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    i++;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>书籍《<a target="_blank" rel="noopener" href="https://qiidb.github.io/zh/publications/9787512329232/">JavaScript模式</a>》中第 6 章「代码复用模式」</li>
<li>Wikipedia 的「<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_copying">Object copying</a>」</li>
<li>MDN Web Docs Glossary 的「<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy">Shallow copy</a>」和「<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy">Deep copy</a>」</li>
</ul>

</div>
      <footer class="Article-footer col-md-3">
  
  <div class="Widget Widget--share">
    <div class="Widget-body">
      <p>分享到<i class="fa fa-share-alt"></i></p>
      <div class="social-share" data-sites="wechat,weibo,twitter"></div>
    </div>
  </div>


  <section class="Widget Widget--toc">
  <div class="Widget-header">
    <h2 class="Widget-title">目录</h2>
  </div>
  <div class="Widget-body"></div>
</section>


</footer>
      
      
    </article>
    

  </div>
</main>
<footer class="Page-footer Footer">
  <div class="container">
    
    <div class="Footer-description">
      
        <!-- Important links -->
        <nav class="Footer-navs">
          <ul><li><a href="https://meta.ourai.ws/?utm_source=https://s.ourai.ws&amp;utm_medium=common-footer" target="_blank" rel="external nofollow"><span>@</span></a>
</li><li><a href="https://ourai.ws/sponsor/?utm_source=https://s.ourai.ws&amp;utm_medium=common-footer" target="_blank" rel="external nofollow"><span>赞助</span></a>
</li><li><a href="https://yaol.in/cooperation/?utm_source=https://s.ourai.ws&amp;utm_medium=common-footer" target="_blank" rel="external nofollow"><span>合作</span></a>
</li></ul>
        </nav>
      
      
        <!-- Copyright -->
        <div class="Footer-copyright">
          <p>

&copy; 2022-2025 <a href="https://ourai.ws/?utm_source=https://s.ourai.ws&amp;utm_medium=common-footer" target="_blank" rel="external nofollow">欧雷流</a> 版权所有

</p>
          <p>本站主题 <a href="https://ourai.github.io/lime/?utm_source=https://s.ourai.ws&amp;utm_medium=common-footer" target="_blank" rel="external nofollow">Lime</a> 由 <a href="https://linxoid.com/ourai/?utm_source=https://s.ourai.ws&amp;utm_medium=common-footer" target="_blank" rel="external nofollow">欧雷</a> 提供</p>
          
        </div>
      
    </div>
  </div>
</footer>





    <script>$('.Article-content > table').addClass('table table-bordered')</script>
    
<script src="/javascripts/ksio/vendors/share.min.js"></script>

<script src="/javascripts/ksio/components/page.js"></script>

<script src="/javascripts/ksio/components/toc.js"></script>

  </body>
</html>

